\chapter{Problemen en oplossingen} % (fold)
\label{cha:problemen_en_oplossingen}
In dit hoofdstuk worden enkele belangrijke problemen besproken die bij de ontwikkeling van de taal naar voren kwamen. Allereerst komt scoping aan bod. Daarna wordt kort de AST besproken, gevolgd door type inferentie. 
\section{Scoping} % (fold)
\label{sec:scoping}
Een belangrijk probleem bij het programmeren in het defini\"eren en gebruik van variabelen in verschillende scopes. Variabelen die bijvoorbeeld binnen een lus worden gedefinieerd, mogen daarbuiten niet gebruikt worden. Ook moet de variabele worden gebruikt die gedeclareerd is onder of in die scope.

Voor het defini\"eren van scopes is de volgende oplossing gekozen. Een scope binnen KIDEB bestaat tussen twee accolades. De scope wordt geopend door een \textquoteleft\{\textquoteright en gesloten door een \textquoteleft\}\textquoteright. Verdere uitleg over scoping is the vinden in subsectie \ref{sub:scope_regels}.

Om bij te houden waar een variabele gedeclareerd is en gebruikt wordt, wordt een symbol table bijgehouden. 
% section scoping (end)

\section{Opbouwen AST} % (fold)
\label{sec:opbouwen_ast}
Voor het opbouwen van onze AST voldeed de standaard node niet. Hiertoe is een eigen node-hi\"erarchie gemaakt. De specificatie van deze nodes is te vinden in hoofdstuk \ref{cha:java_programmatuur}.

Een ander probleem met de AST is het moeten gebruiken van CommonNode voor de belangrijke node dublicatie. Om dit te voorkomen heeft de klasse AbstractNode, als subklasse van CommonNode, een functie met generiek type. Hier kunnen subklassen van CommonNode toch de methode \emph{getDuplicate()} gebruiken.
% section opbouwen_ast (end)

\section{Type inferentie} % (fold)
\label{sec:type_inferentie}

% section type_inferentie (end)

\section{Import statement} % (fold)
\label{sec:import_statement}
Een belangrijke functie in onze taal is het importeren van code. Dit is een lastig probleem, met een vrij simpele oplossing. Op de plek van het import-statement wordt in de AST van het hoofdprogramma de AST van de ge\"importeerde code geplaatst. Hierdoor is de code ook in het hoofdprogramma te gebruiken.
% section import_statement (end)

\section{Arrays als argument} % (fold)
\label{sec:arrays_als_argument}
Het is niet mogelijk om in een functiedeclaratie een array mee te geven zonder een expressie binnen de blokhaken. Het is echter absoluut niet wenselijk te eisen dat arrays als argument voor een functie een vaste lengte hebben. Om dit probleem te verhelpen moeten functies die een array nodig heeft een pointer naar deze array mee krijgen, in plaats van de array zelf.
% section arrays_als_argument (end)

% chapter problemen_&_oplossingen (end)
\clearpage